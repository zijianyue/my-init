
	 ;; (define-key ac-mode-map  (kbd "M-RET") 'auto-complete)
	 (define-key ac-completing-map  (kbd "M-s") 'ac-isearch)

	 (ac-config-default)
	 
	 (add-to-list 'ac-modes 'objc-mode)

	 ;; (setq-default ac-sources '(ac-source-dictionary ac-source-words-in-same-mode-buffers))
	 ;; (setq-default ac-sources '(ac-source-dictionary))
	 ;; (define-key irony-mode-map (kbd "M-p") 'ac-complete-irony-async)
	 ))

;; company
(autoload 'company-mode "company" nil t)
(eval-after-load "company"
  '(progn
	 (require 'company-irony nil t )
	 (setq company-async-timeout 15)
	 ;; (add-hook 'after-init-hook 'global-company-mode)
	 (add-to-list 'company-backends 'company-irony)
	 (add-hook 'irony-mode-hook 'company-irony-setup-begin-commands)
	 ;; (global-set-key (kbd "<S-return>") 'company-complete-common)
	 (global-set-key (kbd "<C-S-return>") 'company-irony)

	 (define-key company-active-map (kbd "<tab>") 'company-complete-common-or-cycle)
	 (define-key company-active-map (kbd "M-s") 'company-filter-candidates)
	 (defun toggle-company-complete-id (&optional args)
	   (interactive "P")
	   (message "company complete id afte %s char" args)
	   (if args
		   (setq-local company-minimum-prefix-length args)
		 (progn
		   (if (eq company-minimum-prefix-length 99)
			   (progn
				 (setq-local company-minimum-prefix-length 3))
			 (progn
			   (setq-local company-minimum-prefix-length 99))))
		 ))
	 ;; 删除时也补全
	 ;; (setq company-begin-commands
	 ;; 	   (cons 'backward-delete-char-untabify company-begin-commands))
	 ;; (setq company-begin-commands
	 ;; 	   (cons 'autopair-backspace company-begin-commands))
	 ;; (add-to-list 'company-backends 'company-c-headers)
	 ))

;;yasnippet
(autoload 'yas-global-mode "yasnippet" nil t)
(autoload 'yas-minor-mode "yasnippet" nil t)
(setq yas-snippet-dirs (concat site-lisp-dir "\\yasnippet\\snippets"))

(setq yas-glo-on nil)
(defun yas-glo-on ()
  (interactive "P")
  (unless yas-glo-on (yas-global-mode 1))
  (setq yas-glo-on t)
  )

;; sln解析
(autoload 'find-sln "sln-mode" nil t)
(eval-after-load "project-buffer-mode"
  '(progn
	 (require 'project-buffer-mode+)
	 (project-buffer-mode-p-setup)
	 (require 'project-buffer-occur)
	 (define-key project-buffer-mode-map [?r] 'project-buffer-occur);; 要想全局搜索需要加C-u
	 (define-key project-buffer-mode-map [?m] 'project-buffer-occur-case-sensitive)
	 ;; (define-key global-map (kbd "<M-f6>") 'project-buffer-mode-p-go-to-attached-project-buffer)
	 ;; (define-key global-map (kbd "<C-f6>") 'project-buffer-mode-p-run-project-buffer-build-action)
	 ))

(global-set-key (kbd "C-c l") 'find-sln)

;; 前进、后退
(require 'recent-jump-small)
(setq rjs-mode-line-format nil)
(recent-jump-small-mode)
(global-set-key (kbd "<M-left>") 'recent-jump-small-backward)
(global-set-key (kbd "<M-right>") 'recent-jump-small-forward)
;; (add-to-list 'rjs-command-ignore 'mwheel-scroll)
(add-to-list 'rjs-command-ignore 'mouse-drag-region)

(defvar rjs-command-ignore-last
  '(recent-jump-backward
    recent-jump-forward
    recent-jump-small-backward
    recent-jump-small-forward
	mwheel-scroll
	mouse-drag-region))

(defun is-mwheeling()
  (and (eq last-command 'mwheel-scroll) (eq this-command 'mwheel-scroll)))

(defun uninterested-buffer (buffer &optional all)
  (if all
	  (or (eq (buffer-local-value 'major-mode buffer) 'dired-mode)
		  (string-match-p "\*" (buffer-name buffer)))
	(or (eq (buffer-local-value 'major-mode buffer) 'ag-mode)
		(eq (buffer-local-value 'major-mode buffer) 'semantic-symref-results-mode)
		(eq (buffer-local-value 'major-mode buffer) 'diff-mode)
		(eq (buffer-local-value 'major-mode buffer) 'vc-dir-mode)
		(eq (buffer-local-value 'major-mode buffer) 'vc-svn-log-view-mode)
		(eq (buffer-local-value 'major-mode buffer) 'ediff-meta-mode)
		(eq (buffer-local-value 'major-mode buffer) 'occur-mode)
		(eq (buffer-local-value 'major-mode buffer) 'Custom-mode)
		(eq (buffer-local-value 'major-mode buffer) 'help-mode)	
		(string-match-p "ag dired pattern" (buffer-name buffer))
		(string-match-p "\*vc\*" (buffer-name buffer))
		(string-match-p "\*Backtrace\*" (buffer-name buffer))
		(string-match-p "\*Completions\*" (buffer-name buffer))
		(string-match-p "\*Cedet\*" (buffer-name buffer))
		(string-match-p "\*Annotate\*" (buffer-name buffer))
		(string-match-p "\*Compile-Log\*" (buffer-name buffer))
		(string-match-p "\*GTAGS SELECT\*" (buffer-name buffer))
		(string-match-p "\*Calc\*" (buffer-name buffer))
		(string-match-p "\*magit" (buffer-name buffer))
		)))

(defun rjs-pre-command-fset ()
  "每个命令执行前执行这个函数"
  (unless (or (active-minibuffer-window) isearch-mode (uninterested-buffer (current-buffer) t) (is-mwheeling))
    (unless (memq this-command rjs-command-ignore)
      (let ((position (list (buffer-file-name) (current-buffer) (point))))
		;; (princ (format " this %S pos:%S" this-command position))
        (unless rjs-position-before
          (setq rjs-position-before position))
        (setq rjs-position-pre-command position))
      (if (memq last-command '(recent-jump-small-backward recent-jump-small-forward))
          (progn
            (let ((index (1- rjs-index)) (list nil))
              (while (> index 0)
                (push (ring-ref rjs-ring index) list)
                (setq index (1- index)))
              (while list
                (ring-insert rjs-ring (car list))
                (pop list))))))))


(defun rjs-post-command-fset ()
  "每个命令执行后执行这个函数"
  (unless (or (active-minibuffer-window) isearch-mode (uninterested-buffer (current-buffer) t) (is-mwheeling))
	(unless (memq this-command rjs-command-ignore)
	  (let ((position (list (buffer-file-name) (current-buffer) (point))))
		;; (princ (format " last %S this %S pos:%S pre:%S before:%S" last-command this-command position rjs-position-pre-command rjs-position-before))
		(if (eq this-command 'mwheel-scroll)
			(rj-insert-point rjs-ring position))
		(if (or (and rjs-position-pre-command
					 (rj-insert-big-jump-point rjs-ring rjs-line-threshold rjs-column-threshold rjs-position-pre-command position rjs-position-pre-command))
				(and rjs-position-before
					 (rj-insert-big-jump-point rjs-ring rjs-line-threshold rjs-column-threshold rjs-position-before position rjs-position-before)))
			(setq rjs-position-before nil)))))
  (setq rjs-position-pre-command nil))

(defun recent-jump-small-backward-fset (arg)
  "跳到命令执行前的位置"
  (interactive "p")
  (let ((index rjs-index)
        (last-is-rjs (memq last-command '(recent-jump-small-backward recent-jump-small-forward))))
    (if (ring-empty-p rjs-ring)
        (message (if (> arg 0) "Can't backward, ring is empty" "Can't forward, ring is empty"))
      (if last-is-rjs
          (setq index (+ index arg))
        (setq index arg)
		(unless (uninterested-buffer (current-buffer) t)
		  (unless (memq last-command rjs-command-ignore-last)
			(let ((position (list (buffer-file-name) (current-buffer) (point))))
			  (setq rj-position-before nil)
			  (unless (rj-insert-big-jump-point rjs-ring rjs-line-threshold rjs-column-threshold (ring-ref rjs-ring 0) position)
				(ring-remove rjs-ring 0)
				(ring-insert rjs-ring position))))))
      (if (>= index (ring-length rjs-ring))
          (message "Can't backward, reach bottom of ring")
        (if (<= index -1)
            (message "Can't forward, reach top of ring")
          (let* ((position (ring-ref rjs-ring index))
				 (file (nth 0 position))
				 (buffer (nth 1 position)))
            (if (not (or file (buffer-live-p buffer)))
                (progn
                  (ring-remove rjs-ring index)
                  (message "要跳转的位置所在的buffer为无文件关联buffer, 但该buffer已被删除"))
              (if file
                  (find-file (nth 0 position))
                (assert (buffer-live-p buffer))
                (switch-to-buffer (nth 1 position)))
              (goto-char (nth 2 position))
              (setq rjs-index index))))))))

(fset 'rjs-pre-command 'rjs-pre-command-fset)
(fset 'rjs-post-command 'rjs-post-command-fset)
(fset 'recent-jump-small-backward 'recent-jump-small-backward-fset)

;; bookmark
(autoload 'bm-toggle   "bm" "Toggle bookmark in current buffer." t)
(autoload 'bm-next     "bm" "Goto bookmark."                     t)
(autoload 'bm-previous "bm" "Goto previous bookmark."            t)
(autoload 'bm-toggle-cycle-all-buffers "bm" nil  t)

(global-set-key (kbd "<C-f2>") 'bm-toggle)
(global-set-key (kbd "<f2>")   'bm-next)
(global-set-key (kbd "<S-f2>") 'bm-previous)
(setq bm-cycle-all-buffers t)
(defface bm-face
  '((((class grayscale)
      (background light)) (:background "DimGray"))
    (((class grayscale)
      (background dark))  (:background "LightGray"))
    (((class color)
      (background light)) (:background "peach puff"))
    (((class color)
      (background dark))  (:background "dark slate gray")))
  "Face used to highlight current line."
  :group 'bm)

;; 更多的语法高亮
(defface zjl-c-hl-function-call-face
  '((t (:foreground "SpringGreen4" :bold t)))
  "*Face used for link privilege indicator (l) in dired buffers."
  :group 'zjl-c-faces)
(defvar zjl-c-hl-function-call-face 'zjl-c-hl-function-call-face)


;; 显示列竖线
(autoload 'fci-mode "fill-column-indicator" "" t)
(global-set-key (kbd "C-:") 'fci-mode)
(setq fci-rule-column 120)
;; (defun fci-all-window-refresh ()
;;   (setq proced-buf-list nil)	;保存已经处理过的buf
;;   (walk-windows
;;    #'(lambda (w)
;; 	   (select-window w)
;; 	   (if (or (eq major-mode 'c-mode)
;; 			   (eq major-mode 'c++-mode))
;; 		   (progn 
;; 			 (unless (and (memq (window-buffer) proced-buf-list)
;; 						  (>= (window-width w) fci-rule-column))
;; 			   (push (window-buffer) proced-buf-list)
;; 			   (turn-on-fci-mode)
;; 			   (if (< (window-width w) fci-rule-column)
;; 				   (turn-off-fci-mode))))))
;;    0))
(eval-after-load "fill-column-indicator"
  '(progn
	 ;; 避免破坏 auto complete
	 (defun sanityinc/fci-enabled-p () (symbol-value 'fci-mode))

	 (defvar sanityinc/fci-mode-suppressed nil)
	 (make-variable-buffer-local 'sanityinc/fci-mode-suppressed)

	 (defadvice popup-create (before suppress-fci-mode activate)
	   "Suspend fci-mode while popups are visible"
	   (let ((fci-enabled (sanityinc/fci-enabled-p)))
		 (when fci-enabled
		   (setq sanityinc/fci-mode-suppressed fci-enabled)
		   (turn-off-fci-mode))))

	 (defadvice popup-delete (after restore-fci-mode activate)
	   "Restore fci-mode when all popups have closed"
	   (when (and sanityinc/fci-mode-suppressed
				  (null popup-instances))
		 (setq sanityinc/fci-mode-suppressed nil)
		 (turn-on-fci-mode)))

	 ;; 避免和company冲突
	 (defvar-local company-fci-mode-on-p nil)

	 (defun company-turn-off-fci (&rest ignore)
	   (when (boundp 'fci-mode)
		 (setq company-fci-mode-on-p fci-mode)
		 (when fci-mode (fci-mode -1))))

	 (defun company-maybe-turn-on-fci (&rest ignore)
	   (when company-fci-mode-on-p (fci-mode 1)))

	 (add-hook 'company-completion-started-hook 'company-turn-off-fci)
	 (add-hook 'company-completion-finished-hook 'company-maybe-turn-on-fci)
	 (add-hook 'company-completion-cancelled-hook 'company-maybe-turn-on-fci)

	 ;; 根据窗口分割情况刷新FCI

	 ;; (defadvice split-window-right (after split-window-right-fci activate)
	 ;;   ""
	 ;;   (fci-all-window-refresh))

	 ;; (defadvice delete-other-windows (after delete-other-windows-fci activate)
	 ;;   ""
	 ;;   (fci-all-window-refresh))

	 ;; (defadvice mouse-delete-window (after mouse-delete-window-fci activate)
	 ;;   ""
	 ;;   (fci-all-window-refresh))

	 ;; (defadvice delete-window (after delete-window-fci activate)
	 ;;   ""
	 ;;   (fci-all-window-refresh))

	 ;; (defadvice switch-to-buffer (after switch-to-buffer-fci activate)
	 ;;   ""
	 ;;   (fci-all-window-refresh))
	 ))
;; 异步copy rename文件
(autoload 'dired-async-mode "dired-async.el" nil t)

;; helm系列
(autoload 'helm-show-kill-ring "helm-config" nil t)
(autoload 'helm-semantic-or-imenu "helm-config" nil t)
(autoload 'helm-for-files "helm-config" nil t)
(autoload 'helm-resume "helm-config" nil t)
(autoload 'helm-M-x "helm-config" nil t)

(autoload 'helm-gtags-mode "helm-gtags" nil t)
(autoload 'helm-gtags-select "helm-gtags" nil t)
(autoload 'helm-gtags-select-path "helm-gtags" nil t)
(autoload 'helm-gtags-find-tag "helm-gtags" nil t)
(autoload 'helm-gtags-find-files "helm-gtags" nil t)
(autoload 'helm-gtags-create-tags "helm-gtags" nil t)
(autoload 'helm-gtags-update-tags "helm-gtags" nil t)
(autoload 'helm-gtags-dwim "helm-gtags" nil t)
(autoload 'helm-gtags-find-rtag "helm-gtags" nil t)

(autoload 'gtags-find-file "gtags" nil t)

(define-key isearch-mode-map (kbd "M-i") 'helm-swoop-from-isearch)

(autoload 'helm-occur "helm-gtags" nil t)
(autoload 'helm-swoop "helm-swoop" nil t)
(autoload 'helm-swoop-from-isearch "helm-swoop" nil t)

(autoload 'helm-ag-this-file "helm-ag" nil t)


(eval-after-load "helm"
  '(progn
	 (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebihnd tab to do persistent action
	 (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
	 (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z
	 ))

(global-set-key (kbd "C-S-v") 'helm-show-kill-ring)
(global-set-key (kbd "<apps>") 'helm-semantic-or-imenu)
(global-set-key (kbd "<C-apps>") 'helm-for-files)
(global-set-key (kbd "<S-apps>") 'helm-resume)
(global-set-key (kbd "<M-apps>") 'helm-ag-this-file)
(global-set-key (kbd "M-]") 'helm-swoop)
(global-set-key (kbd "M-X") 'helm-M-x)

(global-set-key (kbd "C-c b") 'helm-gtags-find-files)
(global-set-key (kbd "C-c B") 'gtags-find-file)
(global-set-key (kbd "C-c d") 'helm-gtags-find-tag)
(global-set-key (kbd "<f6>") 'helm-gtags-select-path)
(global-set-key (kbd "<f7>") 'helm-gtags-select)
(global-set-key (kbd "<S-f5>") 'helm-gtags-create-tags)
(global-set-key (kbd "<f5>") 'helm-gtags-update-tags)
(global-set-key (kbd "C-\\") 'helm-gtags-dwim)
(global-set-key (kbd "C-c r") 'helm-gtags-find-rtag)

(eval-after-load "helm-gtags"
  '(progn
	 (gtags-mode 1)
	 (define-key helm-gtags-mode-map (kbd "C-]") nil)
	 (define-key helm-gtags-mode-map (kbd "C-t") nil)
	 (define-key helm-gtags-mode-map (kbd "M-*") nil)
	 (define-key helm-gtags-mode-map (kbd "M-,") nil)
	 (define-key helm-gtags-mode-map (kbd "M-.") nil)
	 (define-key helm-gtags-mode-map (kbd "C-c t") nil)
	 (define-key helm-gtags-mode-map (kbd "C-c s") 'helm-gtags-find-symbol)
	 (define-key helm-gtags-mode-map (kbd "C-c r") 'helm-gtags-find-rtag)
	 (define-key helm-gtags-mode-map (kbd "C-c f") 'helm-gtags-parse-file)
	 (define-key helm-gtags-mode-map (kbd "C-c g") 'helm-gtags-find-pattern)
	 (define-key helm-gtags-mode-map (kbd "C-\\") 'helm-gtags-dwim)
	 (define-key helm-gtags-mode-map (kbd "C-<") 'helm-gtags-previous-history)
	 (define-key helm-gtags-mode-map (kbd "C->") 'helm-gtags-next-history)
	 (define-key helm-gtags-mode-map (kbd "C-|") 'helm-gtags-find-tag-other-window)
	 (define-key helm-gtags-mode-map (kbd "C-M-,") 'helm-gtags-show-stack)
	 ))

(add-hook 'helm-update-hook
		  (lambda ()
			(setq truncate-lines t)))
;; 自定义的mru
(defvar semantic-tags-location-ring (make-ring 30))

;; flycheck
;; (defvar package-user-dir "")			;防止check lisp出错
(autoload 'flycheck-mode "flycheck" nil t)
(global-set-key (kbd "M-g l") 'flycheck-list-errors)
(global-set-key (kbd "<M-f5>") (lambda () "" (interactive)
								 ;; (require 'irony-cdb nil t)
								 ;; (irony-mode)
								 ;; (irony--mode-exit)
								 (unless flycheck-mode (flycheck-mode 1))
								 (flycheck-buffer)
								 ))

;; irony-mode
(eval-after-load "cc-mode"
  '(progn
	 (require 'irony-cdb nil t)
	 (require 'irony-eldoc )
	 (eldoc-mode 0)
	 ))

(eval-after-load "irony"
  '(progn
	 (defun my-irony-mode-hook ()
	   (define-key irony-mode-map [remap completion-at-point]
		 'irony-completion-at-point-async)
	   (define-key irony-mode-map [remap complete-symbol]
		 'irony-completion-at-point-async))
	 (add-hook 'irony-mode-hook 'my-irony-mode-hook)
	 (add-hook 'irony-mode-hook 'irony-cdb-autosetup-compile-options)
	 (add-hook 'irony-mode-hook 'irony-eldoc)
	 (setq w32-pipe-read-delay 0)
	 (setq process-adaptive-read-buffering nil)
	 (require 'flycheck-irony )
	 (add-to-list 'flycheck-checkers 'irony)
	 (fset 'irony--send-parse-request 'irony--send-parse-request-fset)
	 (require 'irony-cdb nil t)
	 (require 'irony-eldoc )
	 (eldoc-mode 0)
	 ))

(defun irony--send-parse-request-fset (request callback &rest args)
  "Send a request that acts on the current buffer to irony-server.
This concerns mainly irony-server commands that do some work on a
translation unit for libclang, the unsaved buffer data are taken
care of."
  (let ((process (irony--get-server-process-create))
        (argv (append (list request
                            "--num-unsaved=1"
                            (irony--get-buffer-path-for-server))
                      args))
        (compile-options (irony--adjust-compile-options)))
    (when (and process (process-live-p process))
      (irony--server-process-push-callback process callback)
      ;; skip narrowing to compute buffer size and content
      (irony--without-narrowing
		;; always make sure to finish with a newline (required by irony-server
		;; to play nice with line buffering even when the file doesn't end with
		;; a newline)
		;;
		;; it is important to send the request atomically rather than using
		;; multiple process-send calls. On Windows at least, if the request is
		;; not atomic, content from subsequent requests can get intermixed with
		;; earlier requests. This may be because of how Emacs behaves when the
		;; buffers to communicate with processes are full (see
		;; http://www.gnu.org/software/emacs/manual/html_node/elisp/Input-to-Processes.html).
		(message "send buffer")
		(process-send-string process
							 (format "%s\n%s\n%s\n%d\n%s\n"
									 (combine-and-quote-strings argv)
									 (combine-and-quote-strings compile-options)
									 buffer-file-name
									 (irony--buffer-size-in-bytes)
									 (string-as-unibyte (buffer-substring-no-properties (point-min) (point-max)))))))))
;; 行号性能改善
(require 'nlinum )
(global-nlinum-mode 1)
;; Preset `nlinum-format' for minimum width.
(defun my-nlinum-mode-hook ()
  (when nlinum-mode
    (setq-local nlinum-format
                (concat "%" (number-to-string
                             ;; Guesstimate number of buffer lines.
                             (ceiling (log (max 1 (/ (buffer-size) 80)) 10)))
                        "d"))))
(add-hook 'nlinum-mode-hook #'my-nlinum-mode-hook)
;; 避免 “ERROR: Invalid face: linum” error
(defun initialize-nlinum (&optional frame)
  (require 'nlinum)
  (add-hook 'prog-mode-hook 'nlinum-mode))
(when (daemonp)
  (add-hook 'window-setup-hook 'initialize-nlinum)
  (defadvice make-frame (around toggle-nlinum-mode compile activate)
	(nlinum-mode -1) ad-do-it (nlinum-mode 1)))

;; lua mode
(autoload 'lua-mode "lua-mode" "Lua editing mode." t)
(add-to-list 'auto-mode-alist '("\\.lua$" . lua-mode))
(add-to-list 'interpreter-mode-alist '("lua" . lua-mode))

;; markdown mode
(autoload 'markdown-mode "markdown-mode"
  "Major mode for editing Markdown files" t)
(add-to-list 'auto-mode-alist '("\\.text\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.markdown\\'" . markdown-mode))
(add-to-list 'auto-mode-alist '("\\.md\\'" . markdown-mode))

;; 打开大文件
(require 'vlf-setup)
(eval-after-load "vlf"
  '(progn
	 (setq vlf-tune-enabled 'stats)
	 (define-key vlf-prefix-map (kbd "C-c j") vlf-mode-map)))

(defadvice vlf (after vlf-after activate)
  ""
  (remove-dos-eol)
  (nlinum-mode 1)
