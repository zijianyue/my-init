		  ;; if found, set foundFlag-p
		  
		  (when (equal (semantic-tag-name (elt tagList i)) whichFunc)
			(setq foundFlag-p t )
			(setq tag (elt tagList i)))

		  (setq i (1+ i))))
	  )
	;; 再找不到就创建一个空tag
	(unless tag
	  (setq tag (semantic-tag "/* COMMENT */" 'variable))
	  (semantic--tag-put-property tag :filename (buffer-file-name)))

    ;; Copy the tag, which adds a :filename property.
    (when tag
      (setq tag (semantic-tag-copy tag nil t))
      ;; Ad this hit to the tag.
      (semantic--tag-put-property tag :hit (list line)))
    tag))
(eval-after-load "symref"
  '(progn
	 (fset 'semantic-symref-hit-to-tag-via-buffer 'semantic-symref-hit-to-tag-via-buffer-fset)))

(defun semantic-symref-produce-list-on-results-fset (res str)
  "(semantic-symref-result-get-tags res nil)"
  (when (not res) (error "No references found"))
  (semantic-symref-result-get-tags res nil)
  (message "Gathering References...done")
  ;; Build a references buffer.
  (let ((buff (get-buffer-create (format "*Symref %s" str))))
    (switch-to-buffer-other-window buff)
    (set-buffer buff)
    (semantic-symref-results-mode)
    (set (make-local-variable 'semantic-symref-current-results) res)
    (semantic-symref-results-dump res)
    (goto-char (point-min))))


(defun semantic-symref-rb-toggle-expand-tag-fset (&optional button)
  "kill non-open buffer and add line num"
  (interactive)
  (let* ((tag (button-get button 'tag))
		 (kill-flag t)
		 (all-buff-list (buffer-list))
		 (buff (semantic-tag-buffer tag))
		 (hits (semantic--tag-get-property tag :hit))
		 (state (button-get button 'state))
		 (text nil))
	
	(let ((foundFlag-p nil )
		  (tag-filename (semantic--tag-get-property tag :filename))
		  (i 0))

	  (while (and
			  (not foundFlag-p)
			  (<= i (length all-buff-list)))

		;; if found, set foundFlag-p
		
		(when (and (buffer-live-p (elt all-buff-list i))
				   (equal (buffer-file-name (elt all-buff-list i)) tag-filename))
		  (setq foundFlag-p t )
		  (setq kill-flag nil))

		(setq i (1+ i))))

    (cond
     ((eq state 'closed)
      (with-current-buffer buff
		(dolist (H hits)
		  (goto-char (point-min))
		  (forward-line (1- H))
		  (beginning-of-line)
		  (back-to-indentation)
		  (setq text (cons (buffer-substring (point) (point-at-eol)) text)))
		(setq text (nreverse text)))
      (goto-char (button-start button))
      (forward-char 1)
      (let ((inhibit-read-only t))
		(delete-char 1)
		(insert "-")
		(button-put button 'state 'open)
		(save-excursion
		  (end-of-line)
		  (while text
			(insert "\n")
			(insert "    ")
			(insert-button (format "[%s] %s" (car hits) (car text))
						   'mouse-face 'highlight
						   'face nil
						   'action 'semantic-symref-rb-goto-match
						   'tag tag
						   'line (car hits))
			(setq text (cdr text)
				  hits (cdr hits))))))
     ((eq state 'open)
      (let ((inhibit-read-only t))
		(button-put button 'state 'closed)
		;; Delete the various bits.
		(goto-char (button-start button))
		(forward-char 1)
		(delete-char 1)
		(insert "+")
		(save-excursion
		  (end-of-line)
		  (forward-char 1)
		  (delete-region (point)
						 (save-excursion
						   (forward-char 1)
						   (forward-line (length hits))
						   (point)))))))
	(if kill-flag
		(kill-buffer buff))
	))

(defun semantic-tag-buffer-fset (tag)
  "打开文件不记入recentf，并且打开较快，用完后最好手动kill"
  (let ((buff (semantic-tag-in-buffer-p tag)))
    (if buff
		buff
      ;; TAG has an originating file, read that file into a buffer, and
      ;; return it.
	  (if (semantic--tag-get-property tag :filename)
		  (save-match-data
			(semantic-find-file-noselect (semantic--tag-get-property tag :filename) t))
		;; TAG is not in Emacs right now, no buffer is available.
		))))

(fset 'semantic-tag-buffer 'semantic-tag-buffer-fset)

(defun semantic-symref-fset ()
  ""
  (interactive)
  (semantic-fetch-tags)
  (let (symbol res)
	(setq symbol (semantic-current-tag))
	;; Gather results and tags
	(message "Gathering References for %s ..." (semantic-tag-name symbol))
	(setq res (semantic-symref-find-references-by-name (semantic-tag-name symbol)))
	(semantic-symref-produce-list-on-results res (semantic-tag-name symbol))))

(eval-after-load "list"
  '(progn
	 (fset 'semantic-symref-rb-toggle-expand-tag 'semantic-symref-rb-toggle-expand-tag-fset)
	 (fset 'semantic-symref 'semantic-symref-fset)
	 (fset 'semantic-symref-produce-list-on-results 'semantic-symref-produce-list-on-results-fset)))

;; 重写cedet函数 end

(defun semantic-symref-find-references-by-symbolname (name &optional scope tool-return)
  ""
  (interactive "sName: ")
  (let* ((inst (semantic-symref-instantiate
				:searchfor name
				:searchtype 'symbolname
				:searchscope (or scope 'project)
				:resulttype 'line))
		 (result (semantic-symref-get-result inst)))
	(when tool-return
	  (set tool-return inst))
	(prog1
		(setq semantic-symref-last-result result)
	  (when (called-interactively-p 'interactive)
		(semantic-symref-data-debug-last-result))))
  )

;; 在symref result里继续symref
(defun symref-in-result()
  ""
  (interactive)
  (let (symbol res flag)
	(setq symbol (thing-at-point 'symbol))
	(setq flag nil)
	(walk-windows
	 #'(lambda (w)
		 (unless flag
		   (other-window 1)
		   (while (or (eq major-mode 'c-mode)
					  (eq major-mode 'c++-mode))
			 ;; (push-button)
			 ;; Gather results and tags
			 (message "Gathering References for %s ..." symbol)
			 (setq res (cond
						((semantic-symref-find-references-by-name symbol))
						((semantic-symref-find-references-by-symbolname symbol))))
			 (semantic-symref-produce-list-on-results res symbol)
			 (setq flag t))
		   )))))


(defun semantic-symref-just-symbol (&optional text)
  ""
  (interactive "*P")
  (semantic-fetch-tags)
  (let (symbol res)
	(setq symbol (thing-at-point 'symbol))
	(if (or text (not symbol))
		(setq symbol (grep-read-regexp)))
	(if (eq text 0)
		(setq symbol (concat "\\<" symbol "\\>")))
	;; Gather results and tags
	(message "Gathering References for %s ..." symbol)
	(setq res (cond
			   ((semantic-symref-find-references-by-name symbol))
			   ((semantic-symref-find-references-by-symbolname symbol))))
	(semantic-symref-produce-list-on-results res symbol)))

(defun semantic-symref-anything (&optional text)
  ""
  (interactive "*P")
  (semantic-fetch-tags)
  (let (symbol res)
	(setq symbol (thing-at-point 'symbol))
	(if (or text (not symbol))
		(setq symbol (grep-read-regexp)))
	(if (eq text 0)
		(setq symbol (concat "\\<" symbol "\\>")))
	;; Gather results and tags
	(message "Gathering References for %s ..." symbol)
	(setq res (semantic-symref-find-text symbol))
	(semantic-symref-produce-list-on-results res symbol)))

(defun semantic-pop-tag-mark ()             
  "popup the tag save by semantic-goto-definition"   
  (interactive)                                                    
  (if (ring-empty-p semantic-tags-location-ring)                   
	  (message "%s" "No more tags available")                      
	(let* ((marker (ring-remove semantic-tags-location-ring 0))    
		   (buff (marker-buffer marker))                        
		   (pos (marker-position marker)))                   
	  (if (not buff)                                               
		  (message "Buffer has been deleted")                    
		(switch-to-buffer buff)                                    
		(goto-char pos))                                           
	  (set-marker marker nil nil))))

(defadvice semantic-ia-fast-jump (before semantic-ia-fast-jump-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice semantic-complete-jump (before semantic-complete-jump-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice semantic-symref-just-symbol (before semantic-symref-just-symbol-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker))
  (window-configuration-to-register :prev-win-layout))

(defadvice semantic-symref-anything (before semantic-symref-anything-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker))
  (window-configuration-to-register :prev-win-layout))

(defadvice semantic-symref-fset (before semantic-symref-tag-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker))
  (window-configuration-to-register :prev-win-layout))

(defadvice helm-gtags-dwim (before helm-gtags-dwim-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice helm-gtags-find-rtag (before helm-gtags-find-rtag-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice helm-gtags-find-tag (before helm-gtags-find-tag-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice helm-gtags-select (before helm-gtags-select-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice helm-gtags-select-path (before helm-gtags-select-path-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice semantic-decoration-include-visit (before semantic-decoration-include-visit-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice my-ag (before ag-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice ag-this-file (before ag-this-file-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice occur (before occur-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice rgrep (before rgrep-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice gtags-find-tag-by-event (before gtags-find-tag-by-event-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice semantic-analyze-proto-impl-toggle (before semantic-analyze-proto-impl-toggle-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice semantic-decoration-include-visit (before semantic-decoration-include-visit-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker)))

(defadvice helm-gtags-find-tag-other-window (after helm-gtags-tag-other-back activate)
  ""
  (select-window (previous-window)))

(defadvice semantic-symref-hide-buffer (after semantic-symref-hide-buffer-after activate)
  ""
  (jump-to-register :prev-win-layout))

(defun ia-fast-jump-other ()
  (interactive "")
  (let ((pos (point)))
	(save-selected-window
	  (switch-to-buffer-other-window (current-buffer))
	  (goto-char pos)
	  (semantic-ia-fast-jump (point)))
	))

(defun set-c-word-mode ()
  ""
  (interactive)
  ;; (require 'cc-mode)
  ;; (set-syntax-table c++-mode-syntax-table)
  ;; (modify-syntax-entry ?- ".")			;-作为标点符号，起到分隔单词作用
  (modify-syntax-entry ?& ".")
  (modify-syntax-entry ?$ ".")
  (modify-syntax-entry ?< ".")
  (modify-syntax-entry ?> ".")
  (modify-syntax-entry ?= ".")
  (modify-syntax-entry ?/ ".")
  (modify-syntax-entry ?_ "w")
  (modify-syntax-entry ?- "w")
  (setq-local bm-cycle-all-buffers nil))

(global-set-key (kbd "C-_") 'set-c-word-mode)

(defun kill-spec-buffers ()
  ""
  (interactive)
  (dolist (buffer (buffer-list))
    (when (uninterested-buffer buffer)
      (kill-buffer buffer))))

(global-set-key (kbd "<C-S-f9>") 'kill-spec-buffers)
;; 也可以用clean-buffer-list,midnight-mode

;; reuse buffer in DIRED
(defadvice dired-find-file (around dired-find-file-single-buffer activate)
  "Replace current buffer if file is a directory."
  (interactive)
  (let ((orig (current-buffer))
        (filename (dired-get-file-for-visit)))
    ad-do-it
    (when (and (file-directory-p filename)
               (not (eq (current-buffer) orig)))
      (kill-buffer orig))))
(defadvice dired-up-directory (around dired-up-directory-single-buffer activate)
  "Replace current buffer if file is a directory."
  (interactive)
  (let ((orig (current-buffer)))
    ad-do-it
    (kill-buffer orig)))

;; 大文件处理
(defun check-large-file-hook ()
  ""
  (when (< (* 150 1024) (buffer-size))
	;; (nlinum-mode -1)
	(setq-local jit-lock-context-time 5)
	(setq-local jit-lock-defer-time 5)
	(setq-local font-lock-maximum-decoration 2)
	(font-lock-refresh-defaults)
	(setq-local semantic-idle-scheduler-idle-time 60)
	(setq-local company-idle-delay 3)
	;; (font-lock-mode -1 )
	;; (jit-lock-mode nil)
	;; (diff-hl-mode -1)
	))
;; 大文件不开semantic
;; (add-to-list 'semantic-inhibit-functions
;;              (lambda () (< (* 400 1024) (buffer-size))))

(defun unix-to-dos-trim-M ()
  (interactive)
  (unless (eq buffer-file-coding-system 'chinese-gbk-dos)
	(set-buffer-file-coding-system 'chinese-gbk-dos t))
  (save-excursion
	(beginning-of-buffer)
	(while (re-search-forward "\^M" nil t)
	  (replace-match "" nil nil)))
  (save-buffer))
(global-set-key (kbd "C-c m") 'unix-to-dos-trim-M) ;注意在大于200K的文件中替换时会卡住，要c-g后反复用此命令

;; 选中当前行
(defun select-current-line ()
  "Select the current line"
  (interactive)
  (end-of-line) ; move to end of line
  (set-mark (line-beginning-position)))

;; 重新打开文件
(defun reopen-file()
  ""
  (interactive)
  (let ((pos (point))
		(file (buffer-file-name)))
	(kill-this-buffer)
	(find-file file)
	(goto-char pos)))

;; 能够去除光标下的高亮
(defun hi-lock--regexps-at-point-fset ()
  (let ((regexps '()))
    ;; When using overlays, there is no ambiguity on the best
    ;; choice of regexp.
    (let ((regexp (concat "\\_<" (thing-at-point 'symbol) "\\_>")))
      (when regexp (push regexp regexps)))
    regexps))
(defun hi-lock-unface-buffer-fset (regexp)
  "Remove highlighting of each match to REGEXP set by hi-lock.
Interactively, prompt for REGEXP, accepting only regexps
previously inserted by hi-lock interactive functions.
If REGEXP is t (or if \\[universal-argument] was specified interactively),
then remove all hi-lock highlighting."
  (interactive
   (cond
    (current-prefix-arg (list t))
    ((and (display-popup-menus-p)
          (listp last-nonmenu-event)
          use-dialog-box)
     (catch 'snafu
       (or
        (x-popup-menu
         t
         (cons
          `keymap
          (cons "Select Pattern to Unhighlight"
                (mapcar (lambda (pattern)
                          (list (car pattern)
                                (format
                                 "%s (%s)" (car pattern)
                                 (hi-lock-keyword->face pattern))
                                (cons nil nil)
                                (car pattern)))
                        hi-lock-interactive-patterns))))
        ;; If the user clicks outside the menu, meaning that they
        ;; change their mind, x-popup-menu returns nil, and
        ;; interactive signals a wrong number of arguments error.
        ;; To prevent that, we return an empty string, which will
        ;; effectively disable the rest of the function.
        (throw 'snafu '("")))))
    (t
     ;; Un-highlighting triggered via keyboard action.
     (unless hi-lock-interactive-patterns
       (error "No highlighting to remove"))
     ;; Infer the regexp to un-highlight based on cursor position.
     (let* ((defaults (or (hi-lock--regexps-at-point)
                          (mapcar #'car hi-lock-interactive-patterns))))
       ;; (list
       ;;  (completing-read (if (null defaults)
       ;;                       "Regexp to unhighlight: "
       ;;                     (format "Regexp to unhighlight (default %s): "
       ;;                             (car defaults)))
       ;;                   hi-lock-interactive-patterns
	   ;; 					 nil t nil nil defaults))
	   (list (car defaults))			;不用读取用户输入，直接用光标下的单词
	   ))))
  (dolist (keyword (if (eq regexp t) hi-lock-interactive-patterns
                     (list (assoc regexp hi-lock-interactive-patterns))))
    (when keyword
      (let ((face (hi-lock-keyword->face keyword)))
        ;; Make `face' the next one to use by default.
        (when (symbolp face)          ;Don't add it if it's a list (bug#13297).
          (add-to-list 'hi-lock--unused-faces (face-name face))))
      ;; FIXME: Calling `font-lock-remove-keywords' causes
      ;; `font-lock-specified-p' to go from nil to non-nil (because it
      ;; calls font-lock-set-defaults).  This is yet-another bug in
      ;; font-lock-add/remove-keywords, which we circumvent here by
      ;; testing `font-lock-fontified' (bug#19796).
      (if font-lock-fontified (font-lock-remove-keywords nil (list keyword)))
      (setq hi-lock-interactive-patterns
            (delq keyword hi-lock-interactive-patterns))
      (remove-overlays
       nil nil 'hi-lock-overlay-regexp (hi-lock--hashcons (car keyword)))
      (font-lock-flush))))

(eval-after-load "hi-lock"
  '(progn 
	 (fset 'hi-lock--regexps-at-point 'hi-lock--regexps-at-point-fset)
	 (fset 'hi-lock-unface-buffer 'hi-lock-unface-buffer-fset)
