  (his-match-paren 1))

(global-set-key (kbd "C-'") 'his-match-paren)
(global-set-key (kbd "C-\"") 'select-match)

;; 复制文件路径(支持buffer中和dired中)
(defun copy-file-name (&optional full)
  "Copy file name of current-buffer.
If FULL is t, copy full file name."
  (interactive "P")
  (if (eq major-mode 'dired-mode)
	  (dired-copy-filename-as-kill full)
	(let ((file (file-name-nondirectory (buffer-file-name) )))
	  (if full
		  (setq file (expand-file-name file)))
	  (if (eq full 0)
		  (kill-new (setq file (replace-regexp-in-string "/" "\\\\" file)))
		(kill-new file))
	  (message "File `%s' copied." file))))

;; dired下m-0 w复制全路径，并且把/换成\ ,M-9不转换
(defadvice dired-copy-filename-as-kill(after copy-full-path activate)
  (let ((strmod (current-kill 0)))
	(if (eq last-command 'kill-region)
		()
	  (when arg
		(if (eq arg 0)
			(kill-new (setq strmod (replace-regexp-in-string "/" "\\\\" strmod)))
		  (kill-new (setq strmod (car (dired-get-marked-files))))))
	  (message "%s" strmod))))

(global-set-key (kbd "<M-f3>") 'copy-file-name) ;加上任意的参数就是复制全路径，比如m-0
(global-set-key (kbd "<C-f3>") 'open-in-desktop-select)

;;剪切、复制当前行
(defadvice kill-ring-save (before slickcopy activate compile)
  "When called interactively with no active region, copy a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
	 (list (line-beginning-position)
		   (line-beginning-position 2)))))

(defadvice kill-region (before slickcut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
	 (list (line-beginning-position)
		   (line-beginning-position 2)))))

(defun setup-program-keybindings()
  (interactive)
  (local-set-key (kbd "<f12>") 'semantic-ia-fast-jump)
  (local-set-key (kbd "<S-f12>") 'semantic-complete-jump)
  (local-set-key (kbd "M-`") 'ia-fast-jump-other)
  (local-set-key (kbd "<C-f12>") 'semantic-symref-just-symbol)
  (local-set-key (kbd "<M-S-f12>") 'semantic-symref-anything)
  (local-set-key (kbd "<C-S-f12>") 'semantic-symref)
  (local-set-key (kbd "<M-f12>") 'semantic-analyze-proto-impl-toggle)
  (local-set-key (kbd "<M-down>") 'senator-next-tag)
  (local-set-key (kbd "<M-up>") 'senator-previous-tag)
  (local-set-key (kbd "M-,") 'semantic-pop-tag-mark)
  )

;;hide ^M
(defun remove-dos-eol ()
  "Do not show ^M in files containing mixed UNIX and DOS line endings."
  (interactive)
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M []))

;; symref加强
(eval-after-load "cc-mode"
  '(progn
	 (require 'semantic/symref/list )
	 ))

;; 解决symref result中用鼠标点结果时会在当前窗口打开,中键不好使，用右键
(defun symref-results-right-click-event (event)
  ""
  (interactive "e")
  (mouse-set-point event)
  (push-button))

;; 重写cedet函数 begin
(eval-after-load "cedet-global"
  '(progn
	 (defun cedet-gnu-global-search-fset (searchtext texttype type scope)
	   "add -s"
	   (let ((flgs (cond ((eq type 'file)
						  "-a")
						 (t "-xa")))
			 (scopeflgs (cond
						 ((eq scope 'project)
						  ""
						  )
						 ((eq scope 'target)
						  "l")))
			 (stflag (cond ((or (eq texttype 'tagname)
								(eq texttype 'tagregexp))
							"")
						   ((eq texttype 'tagcompletions)
							"c")
						   ((eq texttype 'regexp)
							"g")
						   ((eq texttype 'symbolname)
							"s")
						   (t "r"))))
		 (cedet-gnu-global-call (list (concat flgs scopeflgs stflag)
									  searchtext))))

	 (fset 'cedet-gnu-global-search 'cedet-gnu-global-search-fset)
	 ))


(defun semantic-symref-hit-to-tag-via-buffer-fset (hit searchtxt searchtype &optional open-buffers)
  "avoid missing reference"
  (let* ((line (car hit))
		 (file (cdr hit))
		 (buff (find-buffer-visiting file))
		 (tag nil)
		 (tagList nil)
		 (whichFunc nil)
		 )
    (cond
     ;; We have a buffer already.  Check it out.
     (buff
      (set-buffer buff))

     ;; We have a table, but it needs a refresh.
     ;; This means we should load in that buffer.
     (t
      (let ((kbuff
			 (if open-buffers
				 ;; Even if we keep the buffers open, don't
				 ;; let EDE ask lots of questions.
				 (let ((ede-auto-add-method 'never))
				   (find-file-noselect file t))
			   ;; When not keeping the buffers open, then
			   ;; don't setup all the fancy froo-froo features
			   ;; either.
			   (semantic-find-file-noselect file t))))
		(set-buffer kbuff)
		(push kbuff semantic-symref-recently-opened-buffers)
		(semantic-fetch-tags)
		))
     )

    ;; Too much baggage in goto-line
    ;; (goto-line line)
    (goto-char (point-min))
    (forward-line (1- line))

    ;; Search forward for the matching text
    (when (re-search-forward searchtxt
							 (point-at-eol)
							 t)
      (goto-char (match-beginning 0))
      )

    (setq tag (semantic-current-tag))
	(unless (zerop (current-indentation))
	  (setq whichFunc (which-function)))
    ;; If we are searching for a tag, but bound the tag we are looking
    ;; for, see if it resides in some other parent tag.
    ;;
    ;; If there is no parent tag, then we still need to hang the originator
    ;; in our list.
    (when (and (eq searchtype 'symbol)
			   (string= (semantic-tag-name tag) searchtxt))
      (setq tag (or (semantic-current-tag-parent) tag)))

	;; 找不到tag时，使用which-fuction匹配本文件所有tag来查
	(unless tag
	  (let ((foundFlag-p nil )
			(i 0))

		(setq tagList (semantic-fetch-tags))
		(while (and
				(not foundFlag-p)
				(<= i (length tagList)))

		  ;; if found, set foundFlag-p
		  
		  (when (equal (semantic-tag-name (elt tagList i)) whichFunc)
			(setq foundFlag-p t )
			(setq tag (elt tagList i)))

		  (setq i (1+ i))))
	  )
	;; 再找不到就创建一个空tag
	(unless tag
	  (setq tag (semantic-tag "/* COMMENT */" 'variable))
	  (semantic--tag-put-property tag :filename (buffer-file-name)))

    ;; Copy the tag, which adds a :filename property.
    (when tag
      (setq tag (semantic-tag-copy tag nil t))
      ;; Ad this hit to the tag.
      (semantic--tag-put-property tag :hit (list line)))
    tag))
(eval-after-load "symref"
  '(progn
	 (fset 'semantic-symref-hit-to-tag-via-buffer 'semantic-symref-hit-to-tag-via-buffer-fset)))

;; semantic-symref-results-dump是symref生成按钮的函数
(defun semantic-symref-produce-list-on-results-fset (res str)
  "(semantic-symref-result-get-tags res nil)"
  (when (not res) (error "No references found"))
  (semantic-symref-result-get-tags res nil)
  (message "Gathering References...done")
  ;; Build a references buffer.
  (let ((buff (get-buffer-create (format "*Symref %s" str))))
    (switch-to-buffer-other-window buff)
    (set-buffer buff)
    (semantic-symref-results-mode)
    (set (make-local-variable 'semantic-symref-current-results) res)
    (semantic-symref-results-dump res)
    (goto-char (point-min))))


(defun semantic-symref-rb-toggle-expand-tag-fset (&optional button)
  "kill non-open buffer and add line num"
  (interactive)
  (let* ((tag (button-get button 'tag))
		 (kill-flag t)
		 (all-buff-list (buffer-list))
		 (buff (semantic-tag-buffer tag))
		 (hits (semantic--tag-get-property tag :hit))
		 (state (button-get button 'state))
		 (text nil))
	
	(let ((foundFlag-p nil )
		  (tag-filename (semantic--tag-get-property tag :filename))
		  (i 0))

	  (while (and
			  (not foundFlag-p)
			  (<= i (length all-buff-list)))

		;; if found, set foundFlag-p
		
		(when (and (buffer-live-p (elt all-buff-list i))
				   (equal (buffer-file-name (elt all-buff-list i)) tag-filename))
		  (setq foundFlag-p t )
		  (setq kill-flag nil))

		(setq i (1+ i))))

    (cond
     ((eq state 'closed)
      (with-current-buffer buff
		(dolist (H hits)
		  (goto-char (point-min))
		  (forward-line (1- H))
		  (beginning-of-line)
		  (back-to-indentation)
		  (setq text (cons (buffer-substring (point) (point-at-eol)) text)))
		(setq text (nreverse text)))
      (goto-char (button-start button))
      (forward-char 1)
      (let ((inhibit-read-only t))
		(delete-char 1)
		(insert "-")
		(button-put button 'state 'open)
		(save-excursion
		  (end-of-line)
		  (while text
			(insert "\n")
			(insert "    ")
			(insert-button (format "[%s] %s" (car hits) (car text))
						   'mouse-face 'highlight
						   'face nil
						   'action 'semantic-symref-rb-goto-match
						   'tag tag
						   'line (car hits))
			(setq text (cdr text)
				  hits (cdr hits))))))
     ((eq state 'open)
      (let ((inhibit-read-only t))
		(button-put button 'state 'closed)
		;; Delete the various bits.
		(goto-char (button-start button))
		(forward-char 1)
		(delete-char 1)
		(insert "+")
		(save-excursion
		  (end-of-line)
		  (forward-char 1)
		  (delete-region (point)
						 (save-excursion
						   (forward-char 1)
						   (forward-line (length hits))
						   (point)))))))
	(if kill-flag
		(kill-buffer buff))
	))

(defun semantic-tag-buffer-fset (tag)
  "打开文件不记入recentf，并且打开较快，用完后最好手动kill"
  (let ((buff (semantic-tag-in-buffer-p tag)))
    (if buff
		buff
      ;; TAG has an originating file, read that file into a buffer, and
      ;; return it.
	  (if (semantic--tag-get-property tag :filename)
		  (save-match-data
			(semantic-find-file-noselect (semantic--tag-get-property tag :filename) t))
		;; TAG is not in Emacs right now, no buffer is available.
		))))

(fset 'semantic-tag-buffer 'semantic-tag-buffer-fset)

(defun semantic-symref-fset ()
  ""
  (interactive)
  (semantic-fetch-tags)
  (let (symbol res)
	(setq symbol (semantic-current-tag))
	;; Gather results and tags
	(message "Gathering References for %s ..." (semantic-tag-name symbol))
	(setq res (semantic-symref-find-references-by-name (semantic-tag-name symbol)))
	(semantic-symref-produce-list-on-results res (semantic-tag-name symbol))))

(eval-after-load "list"
  '(progn
	 (fset 'semantic-symref-rb-toggle-expand-tag 'semantic-symref-rb-toggle-expand-tag-fset)
	 (fset 'semantic-symref 'semantic-symref-fset)
	 (fset 'semantic-symref-produce-list-on-results 'semantic-symref-produce-list-on-results-fset)
     ;; (fset 'semantic-symref-results-dump 'semantic-symref-results-dump-fset)
     ;; (fset 'semantic-symref-rb-toggle-expand-tag 'semantic-symref-rb-toggle-expand-tag-fset)
     ))

;; 重写cedet函数 end

(defun semantic-symref-find-references-by-symbolname (name &optional scope tool-return)
  ""
  (interactive "sName: ")
  (let* ((inst (semantic-symref-instantiate
				:searchfor name
				:searchtype 'symbolname
				:searchscope (or scope 'project)
				:resulttype 'line))
		 (result (semantic-symref-get-result inst)))
	(when tool-return
	  (set tool-return inst))
	(prog1
		(setq semantic-symref-last-result result)
	  (when (called-interactively-p 'interactive)
		(semantic-symref-data-debug-last-result))))
  )

;; 在symref result里继续symref
(defun symref-in-result()
  ""
  (interactive)
  (let (symbol res flag)
	(setq symbol (thing-at-point 'symbol))
	(setq flag nil)
	(walk-windows
	 #'(lambda (w)
		 (unless flag
		   (other-window 1)
		   (while (or (eq major-mode 'c-mode)
					  (eq major-mode 'c++-mode))
			 ;; (push-button)
			 ;; Gather results and tags
			 (message "Gathering References for %s ..." symbol)
			 (setq res (cond
						((semantic-symref-find-references-by-name symbol))
						((semantic-symref-find-references-by-symbolname symbol))))
			 (semantic-symref-produce-list-on-results res symbol)
			 (setq flag t))
		   )))))


(defun semantic-symref-just-symbol (&optional text)
  ""
  (interactive "*P")
  (semantic-fetch-tags)
  (let (symbol res)
	(setq symbol (thing-at-point 'symbol))
	(if (or text (not symbol))
		(setq symbol (grep-read-regexp)))
	(if (eq text 0)
		(setq symbol (concat "\\<" symbol "\\>")))
	;; Gather results and tags
	(message "Gathering References for %s ..." symbol)
	(setq res (cond
			   ((semantic-symref-find-references-by-name symbol))
			   ((semantic-symref-find-references-by-symbolname symbol))))
	(semantic-symref-produce-list-on-results res symbol)))

(defun semantic-symref-anything (&optional text)
  ""
  (interactive "*P")
  (semantic-fetch-tags)
  (let (symbol res)
	(setq symbol (thing-at-point 'symbol))
	(if (or text (not symbol))
		(setq symbol (grep-read-regexp)))
	(if (eq text 0)
		(setq symbol (concat "\\<" symbol "\\>")))
	;; Gather results and tags
	(message "Gathering References for %s ..." symbol)
	(setq res (semantic-symref-find-text symbol))
	(semantic-symref-produce-list-on-results res symbol)))

(defun semantic-pop-tag-mark ()             
  "popup the tag save by semantic-goto-definition"   
  (interactive)                                                    
  (if (ring-empty-p semantic-tags-location-ring)                   
	  (message "%s" "No more tags available")                      
	(let* ((marker (ring-remove semantic-tags-location-ring 0))    
		   (buff (marker-buffer marker))                        
		   (pos (marker-position marker)))                   
	  (if (not buff)                                               
		  (message "Buffer has been deleted")                    
		(switch-to-buffer buff)                                    
		(goto-char pos))                                           
	  (set-marker marker nil nil))))

(dolist (command '(semantic-ia-fast-jump semantic-complete-jump helm-gtags-dwim helm-gtags-find-rtag helm-gtags-find-tag helm-gtags-select helm-gtags-select-path
                                         semantic-decoration-include-visit my-ag ag-this-file occur rgrep gtags-find-tag-by-event
                                         semantic-analyze-proto-impl-toggle semantic-decoration-include-visit ff-find-other-file))
  (eval
   `(defadvice ,command (before jump-mru activate)
      (ring-insert semantic-tags-location-ring (point-marker))
      (window-configuration-to-register :prev-win-layout))))
        

(defadvice helm-gtags-find-tag-other-window (after helm-gtags-tag-other-back activate)
  ""
  (select-window (previous-window)))

(defadvice semantic-symref-just-symbol (before semantic-symref-just-symbol-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker))
  (window-configuration-to-register :prev-win-layout))

(defadvice semantic-symref-anything (before semantic-symref-anything-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker))
  (window-configuration-to-register :prev-win-layout))

(defadvice semantic-symref-fset (before semantic-symref-tag-mru activate)
  ""
  (ring-insert semantic-tags-location-ring (point-marker))
  (window-configuration-to-register :prev-win-layout))

(defadvice semantic-symref-hide-buffer (after semantic-symref-hide-buffer-after activate)
  ""
  (jump-to-register :prev-win-layout))

(defun ia-fast-jump-other ()
  (interactive "")
  (let ((pos (point)))
	(save-selected-window
	  (switch-to-buffer-other-window (current-buffer))
	  (goto-char pos)
	  (semantic-ia-fast-jump (point)))
	))

(defun set-c-word-mode ()
  ""
  (interactive)
  ;; (require 'cc-mode)
  ;; (set-syntax-table c++-mode-syntax-table)
  ;; (modify-syntax-entry ?- ".")			;-作为标点符号，起到分隔单词作用
  (modify-syntax-entry ?& ".")
  (modify-syntax-entry ?$ ".")
  (modify-syntax-entry ?< ".")
  (modify-syntax-entry ?> ".")
  (modify-syntax-entry ?= ".")
  (modify-syntax-entry ?/ ".")
  (modify-syntax-entry ?_ "w")
  (modify-syntax-entry ?- "w")
  (setq-local bm-cycle-all-buffers nil))

(global-set-key (kbd "C-_") 'set-c-word-mode)

(defun kill-spec-buffers ()
  ""
  (interactive)
  (dolist (buffer (buffer-list))
    (when (uninterested-buffer buffer)
      (kill-buffer buffer))))

(global-set-key (kbd "<C-S-f9>") 'kill-spec-buffers)
;; 也可以用clean-buffer-list,midnight-mode

;; reuse buffer in DIRED
(defadvice dired-find-file (around dired-find-file-single-buffer activate)
  "Replace current buffer if file is a directory."
  (interactive)
  (let ((orig (current-buffer))
        (filename (dired-get-file-for-visit)))
    ad-do-it
    (when (and (file-directory-p filename)
               (not (eq (current-buffer) orig)))
      (kill-buffer orig))))
