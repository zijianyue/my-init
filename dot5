(defun my-c-mode-common-hook-if0 ()
  (font-lock-add-keywords
   nil
   '((my-c-mode-font-lock-if0 (0 shadow prepend))) 'add-to-end))


;; 添加删除注释
(defun qiang-comment-dwim-line (&optional arg)
  "Replacement for the comment-dwim command.
If no region is selected and current line is not blank and we are not at the end of the line,
then comment current line.
Replaces default behaviour of comment-dwim, when it inserts comment at the end of the line."
  (interactive "*P")
  (comment-normalize-vars)
  (if (and (not (region-active-p)) (not (looking-at "[ \t]*$")))
	  (comment-or-uncomment-region (line-beginning-position) (line-end-position))
	(comment-dwim arg)))

(global-set-key "\M-'" 'qiang-comment-dwim-line) ;; 已有comment-line c-x c-;代替


;; 拷贝代码自动格式化默认是粘贴完后按c-m-\会格式化粘贴内容)
(dolist (command '(yank yank-pop))
  (eval
   `(defadvice ,command (after indent-region activate)
	  (and (not current-prefix-arg)
		   (member major-mode
				   '(emacs-lisp-mode
					 lisp-mode
					 c-mode
					 c++-mode
					 ))
		   (let ((mark-even-if-inactive transient-mark-mode))
			 (indent-region (region-beginning) (region-end) nil))))))

;; 跳到匹配的括号处
(defun his-match-paren (arg)
  "Go to the matching paren if on a paren; otherwise insert %."
  (interactive "p")
  (let ((prev-char (char-to-string (preceding-char)))
		(next-char (char-to-string (following-char))))
	(cond ((string-match "[[{(<（]" next-char) (forward-sexp 1))
		  ((string-match "[\]})>）]" prev-char) (backward-sexp 1))
		  )))

;; 选中括号间的内容
(defun select-match ()
  "select between match paren"
  (interactive)
  (cua-set-mark)
  (his-match-paren 1))

(global-set-key (kbd "C-'") 'his-match-paren)
(global-set-key (kbd "C-\"") 'select-match)

;; 复制文件路径(支持buffer中和dired中)
(defun copy-file-name (&optional full)
  "Copy file name of current-buffer.
If FULL is t, copy full file name."
  (interactive "P")
  (if (eq major-mode 'dired-mode)
	  (dired-copy-filename-as-kill full)
	(let ((file (file-name-nondirectory (buffer-file-name) )))
	  (if full
		  (setq file (expand-file-name file)))
	  (if (eq full 0)
		  (kill-new (setq file (replace-regexp-in-string "/" "\\\\" file)))
		(kill-new file))
	  (message "File `%s' copied." file))))

;; dired下m-0 w复制全路径，并且把/换成\ ,M-9不转换
(defadvice dired-copy-filename-as-kill(after copy-full-path activate)
  (let ((strmod (current-kill 0)))
	(if (eq last-command 'kill-region)
		()
	  (when arg
		(if (eq arg 0)
			(kill-new (setq strmod (replace-regexp-in-string "/" "\\\\" strmod)))
		  (kill-new (setq strmod (car (dired-get-marked-files))))))
	  (message "%s" strmod))))

(global-set-key (kbd "<M-f3>") 'copy-file-name) ;加上任意的参数就是复制全路径，比如m-0
(global-set-key (kbd "<C-f3>") 'open-in-desktop-select)

;;剪切、复制当前行
(defadvice kill-ring-save (before slickcopy activate compile)
  "When called interactively with no active region, copy a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
	 (list (line-beginning-position)
		   (line-beginning-position 2)))))

(defadvice kill-region (before slickcut activate compile)
  "When called interactively with no active region, kill a single line instead."
  (interactive
   (if mark-active (list (region-beginning) (region-end))
	 (list (line-beginning-position)
		   (line-beginning-position 2)))))

(defun setup-program-keybindings()
  (interactive)
  (local-set-key (kbd "<f12>") 'semantic-ia-fast-jump)
  (local-set-key (kbd "<S-f12>") 'semantic-complete-jump)
  (local-set-key (kbd "M-`") 'ia-fast-jump-other)
  (local-set-key (kbd "<C-f12>") 'semantic-symref-just-symbol)
  (local-set-key (kbd "<M-S-f12>") 'semantic-symref-anything)
  (local-set-key (kbd "<C-S-f12>") 'semantic-symref)
  (local-set-key (kbd "<M-f12>") 'semantic-analyze-proto-impl-toggle)
  (local-set-key (kbd "<M-down>") 'senator-next-tag)
  (local-set-key (kbd "<M-up>") 'senator-previous-tag)
  (local-set-key (kbd "M-,") 'semantic-pop-tag-mark)
  )

;;hide ^M
(defun remove-dos-eol ()
  "Do not show ^M in files containing mixed UNIX and DOS line endings."
  (interactive)
  (setq buffer-display-table (make-display-table))
  (aset buffer-display-table ?\^M []))

;; symref加强
(eval-after-load "cc-mode"
  '(progn
	 (require 'semantic/symref/list )
	 ))

;; 重写cedet函数 begin
(eval-after-load "cedet-global"
  '(progn
(defun cedet-gnu-global-search-fset (searchtext texttype type scope)
  "add -s"
  (let ((flgs (cond ((eq type 'file)
					 "-a")
					(t "-xa")))
		(scopeflgs (cond
					((eq scope 'project)
					 ""
					 )
					((eq scope 'target)
					 "l")))
		(stflag (cond ((or (eq texttype 'tagname)
						   (eq texttype 'tagregexp))
					   "")
					  ((eq texttype 'tagcompletions)
					   "c")
					  ((eq texttype 'regexp)
					   "g")
					  ((eq texttype 'symbolname)
					   "s")
					  (t "r"))))
    (cedet-gnu-global-call (list (concat flgs scopeflgs stflag)
								 searchtext))))

(fset 'cedet-gnu-global-search 'cedet-gnu-global-search-fset)
	 ))


(defun semantic-symref-hit-to-tag-via-buffer-fset (hit searchtxt searchtype &optional open-buffers)
  "avoid missing reference"
  (let* ((line (car hit))
		 (file (cdr hit))
		 (buff (find-buffer-visiting file))
		 (tag nil)
		 (tagList nil)
		 (whichFunc nil)
		 )
    (cond
     ;; We have a buffer already.  Check it out.
     (buff
      (set-buffer buff))

     ;; We have a table, but it needs a refresh.
     ;; This means we should load in that buffer.
     (t
      (let ((kbuff
			 (if open-buffers
				 ;; Even if we keep the buffers open, don't
				 ;; let EDE ask lots of questions.
				 (let ((ede-auto-add-method 'never))
				   (find-file-noselect file t))
			   ;; When not keeping the buffers open, then
			   ;; don't setup all the fancy froo-froo features
			   ;; either.
			   (semantic-find-file-noselect file t))))
		(set-buffer kbuff)
		(push kbuff semantic-symref-recently-opened-buffers)
		(semantic-fetch-tags)
		))
     )

    ;; Too much baggage in goto-line
    ;; (goto-line line)
    (goto-char (point-min))
    (forward-line (1- line))

    ;; Search forward for the matching text
    (when (re-search-forward searchtxt
							 (point-at-eol)
							 t)
      (goto-char (match-beginning 0))
      )

    (setq tag (semantic-current-tag))
	(unless (zerop (current-indentation))
	  (setq whichFunc (which-function)))
    ;; If we are searching for a tag, but bound the tag we are looking
    ;; for, see if it resides in some other parent tag.
    ;;
    ;; If there is no parent tag, then we still need to hang the originator
    ;; in our list.
    (when (and (eq searchtype 'symbol)
			   (string= (semantic-tag-name tag) searchtxt))
      (setq tag (or (semantic-current-tag-parent) tag)))

	;; 找不到tag时，使用which-fuction匹配本文件所有tag来查
	(unless tag
	  (let ((foundFlag-p nil )
			(i 0))

		(setq tagList (semantic-fetch-tags))
		(while (and
				(not foundFlag-p)
				(<= i (length tagList)))

		  ;; if found, set foundFlag-p
		  
		  (when (equal (semantic-tag-name (elt tagList i)) whichFunc)
			(setq foundFlag-p t )
			(setq tag (elt tagList i)))

		  (setq i (1+ i))))
	  )
	;; 再找不到就创建一个空tag
	(unless tag
	  (setq tag (semantic-tag "/* COMMENT */" 'variable))
	  (semantic--tag-put-property tag :filename (buffer-file-name)))

    ;; Copy the tag, which adds a :filename property.
    (when tag
      (setq tag (semantic-tag-copy tag nil t))
      ;; Ad this hit to the tag.
      (semantic--tag-put-property tag :hit (list line)))
    tag))

(fset 'semantic-symref-hit-to-tag-via-buffer 'semantic-symref-hit-to-tag-via-buffer-fset)

(defun semantic-symref-produce-list-on-results-fset (res str)
  "(semantic-symref-result-get-tags res nil)"
  (when (not res) (error "No references found"))
  (semantic-symref-result-get-tags res nil)
  (message "Gathering References...done")
  ;; Build a references buffer.
  (let ((buff (get-buffer-create (format "*Symref %s" str))))
    (switch-to-buffer-other-window buff)
    (set-buffer buff)
    (semantic-symref-results-mode)
    (set (make-local-variable 'semantic-symref-current-results) res)
    (semantic-symref-results-dump res)
    (goto-char (point-min))))


(defun semantic-symref-rb-toggle-expand-tag-fset (&optional button)
  "kill non-open buffer and add line num"
  (interactive)
  (let* ((tag (button-get button 'tag))
		 (kill-flag t)
		 (all-buff-list (buffer-list))
		 (buff (semantic-tag-buffer tag))
		 (hits (semantic--tag-get-property tag :hit))
		 (state (button-get button 'state))
		 (text nil))
	
	(let ((foundFlag-p nil )
		  (tag-filename (semantic--tag-get-property tag :filename))
		  (i 0))

	  (while (and
			  (not foundFlag-p)
			  (<= i (length all-buff-list)))

		;; if found, set foundFlag-p
		
		(when (and (buffer-live-p (elt all-buff-list i))
				   (equal (buffer-file-name (elt all-buff-list i)) tag-filename))
		  (setq foundFlag-p t )
		  (setq kill-flag nil))

		(setq i (1+ i))))

    (cond
     ((eq state 'closed)
      (with-current-buffer buff
		(dolist (H hits)
		  (goto-char (point-min))
		  (forward-line (1- H))
		  (beginning-of-line)
		  (back-to-indentation)
		  (setq text (cons (buffer-substring (point) (point-at-eol)) text)))
		(setq text (nreverse text)))
      (goto-char (button-start button))
      (forward-char 1)
      (let ((inhibit-read-only t))
		(delete-char 1)
		(insert "-")
		(button-put button 'state 'open)
		(save-excursion
		  (end-of-line)
		  (while text
			(insert "\n")
			(insert "    ")
			(insert-button (format "[%s] %s" (car hits) (car text))
						   'mouse-face 'highlight
						   'face nil
						   'action 'semantic-symref-rb-goto-match
						   'tag tag
						   'line (car hits))
			(setq text (cdr text)
				  hits (cdr hits))))))
     ((eq state 'open)
      (let ((inhibit-read-only t))
		(button-put button 'state 'closed)
		;; Delete the various bits.
		(goto-char (button-start button))
		(forward-char 1)
		(delete-char 1)
		(insert "+")
		(save-excursion
		  (end-of-line)
		  (forward-char 1)
		  (delete-region (point)
						 (save-excursion
						   (forward-char 1)
						   (forward-line (length hits))
						   (point)))))))
	(if kill-flag
		(kill-buffer buff))
	))

(defun semantic-tag-buffer-fset (tag)
  "打开文件不记入recentf，并且打开较快，用完后最好手动kill"
  (let ((buff (semantic-tag-in-buffer-p tag)))
    (if buff
		buff
      ;; TAG has an originating file, read that file into a buffer, and
      ;; return it.
	  (if (semantic--tag-get-property tag :filename)
		  (save-match-data
			(semantic-find-file-noselect (semantic--tag-get-property tag :filename) t))
		;; TAG is not in Emacs right now, no buffer is available.
		))))

(fset 'semantic-tag-buffer 'semantic-tag-buffer-fset)

(defun semantic-symref-fset ()
  ""
  (interactive)
  (semantic-fetch-tags)
  (let (symbol res)
	(setq symbol (semantic-current-tag))
	;; Gather results and tags
	(message "Gathering References for %s ..." (semantic-tag-name symbol))
	(setq res (semantic-symref-find-references-by-name (semantic-tag-name symbol)))
	(semantic-symref-produce-list-on-results res (semantic-tag-name symbol))))

(eval-after-load "list"
  '(progn
	 (fset 'semantic-symref-rb-toggle-expand-tag 'semantic-symref-rb-toggle-expand-tag-fset)
	 (fset 'semantic-symref 'semantic-symref-fset)
	 (fset 'semantic-symref-produce-list-on-results 'semantic-symref-produce-list-on-results-fset)))

;; 重写cedet函数 end

(defun semantic-symref-find-references-by-symbolname (name &optional scope tool-return)
  ""
  (interactive "sName: ")
  (let* ((inst (semantic-symref-instantiate
				:searchfor name
				:searchtype 'symbolname
				:searchscope (or scope 'project)
				:resulttype 'line))
		 (result (semantic-symref-get-result inst)))
	(when tool-return
	  (set tool-return inst))
	(prog1
		(setq semantic-symref-last-result result)
	  (when (called-interactively-p 'interactive)
		(semantic-symref-data-debug-last-result))))
  )


(defun semantic-symref-just-symbol (&optional text)
  ""
  (interactive "*P")
  (semantic-fetch-tags)
  (let (symbol res)
	(setq symbol (thing-at-point 'symbol))
	(if (or text (not symbol))
		(setq symbol (grep-read-regexp)))
	(if (eq text 0)
		(setq symbol (concat "\\<" symbol "\\>")))
